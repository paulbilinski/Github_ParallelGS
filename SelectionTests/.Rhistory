p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
geweke.diag(theta.samples)
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
accepted.moves/ngen #little high, moving slowly, can just move uniformProposal to be bigger
plot(theta.samples,ylim=c(0,1),type='l')
geweke.diag(theta.samples)
effectiveSize(theta.samples)
ngen=1e3
sample.freq=1
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
#acceptance rate
accepted.moves/ngen #little high, moving slowly, can just move uniformProposal to be bigger
plot(theta.samples,ylim=c(0,1),type='l')
#install.packages('coda')
library(coda)
geweke.diag(theta.samples)
effectiveSize(theta.samples)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
plot(theta.samples,ylim=c(0,1),type='l')
5E-5
5E-5 > 6E-5
5E-5 < 6E-5
fit <- aov()
?aov()
library ( mvtnorm )
source('~/.active-rstudio-document', echo=TRUE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
print(ANOVA)
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
phenoteo <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_averages.csv",header=TRUE)
View(phenoteo)
genoteo <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteAll_Bayenv.csv",header=FALSE)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
genoteo <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteAll_Bayenv.csv",header=FALSE)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knob.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knob.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$TR1MB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$TR1.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$CentCMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$CentC.,genoteo,phenoteo$Altitude)
```
phenoparv <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_parv_avg.csv",header=TRUE)
genoparv <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteParv_Bayenv.csv",header=FALSE)
EnvVarTest(phenoparv$X180knobMB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$X180knob.,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$TR1MB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$TR1.,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$CentCMB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$CentC.,genoparv,phenoparv$Altitude)
View(genoteo)
phenomex <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_mex_avg.csv",header=TRUE)
genomex <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteMex_Bayenv.csv",header=FALSE)
EnvVarTest(phenomex$X180knobMB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$X180knob.,genomex,phenomex$Altitude)
EnvVarTest(phenomex$TR1MB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$TR1.,genomex,phenomex$Altitude)
EnvVarTest(phenomex$CentCMB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$CentC.,genomex,phenomex$Altitude)
mvrnorm()
install.packages("MASS")
library(MASS)
setwd("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SelectionTests/")
library("rrBLUP")
geno <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/Landrace_noSWUS_matrix.csv",header=TRUE,row.names=1)
dt <-t(geno)
A <- A.mat(dt)
pheno <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Landraces_noSWUS_pheno.csv",header=TRUE)
#to make sure order is the same
tmp1 <- as.data.frame(colnames(geno))
names(tmp1)[1] <- "names"
tmp2 <- as.data.frame(pheno$FullID)
tmp <- setdiff(tmp1,tmp2)
phenoorder <- merge(tmp1,pheno, by.x="names", by.y="FullID",sort=FALSE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
print(ANOVA)
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
EnvVarTest(phenoorder$X180knobMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$X180knob.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1MB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentCMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentC.,A,phenoorder$Altitude)
View(pheno)
mu <- rep(0, 83)
simpheno <- mvrnorm(n=83,mu, A) #n=number of samples we have, for maize 83, for allteo 16 pop
View(simpheno)
simpheno <- mvrnorm(n=82,mu, A) #n=number of samples we have, for maize 83, for allteo 16 pop
simpheno <- mvrnorm(n=83,mu, A) #n=number of samples we have, for maize 83, for allteo 16 pop
Altitude <- phenoorder$Altitude
pizza <- mu + B * Altitude
B <- 10
pizza <- mu + B * Altitude
mu <- rep(0, 1000) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 10
pizza <- mu + B * Altitude
simpheno <- mvrnorm(n=83,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
mu <- rep(0, 1) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 10
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=83,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
View(simpheno)
mu <- rep(0, 1) #I think since we want 1K sims, we want to make the length of this 1k
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 10
pizza <- mu + B * Altitude
simpheno <- mvrnorm(n=83,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
View(simpheno)
View(geno)
View(A)
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
View(simpheno)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
print(ANOVA)
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
EnvVarTest(simpheno[1,],A,Altitude)
EnvVarTest(simpheno[2,],A,Altitude)
sapply(simpheno,function(X) EnvVarTest(simpheno[X,],A,Altitude))
sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude))
EnvVarTest(simpheno[X,],A,Altitude)
X=3
EnvVarTest(simpheno[X,],A,Altitude)
EnvVarTest(simpheno[X,],A,Altitude)[3]
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
pvals
plot(density(pvals))
B <- 100
pizza <- mu + B * Altitude
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude)
plot(density(pvals))
B <- 1000
pizza <- mu + B * Altitude
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
#print(ANOVA)
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
plot(pvals)
plot(density(pvals)
)
simpheno <- mvrnorm(n=1000,pizza, 10*A) #n=number of samples we have, for maize 83, for allteo 16 pop
simpheno <- mvrnorm(n=1000,pizza, 10*A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
plot(density(pvals)
)
simpheno[1,]
simpheno <- mvrnorm(n=1,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
simpheno <- mvrnorm(n=1,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
simpheno[1,])
simpheno
B <- 0.1
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
B <- 0.1
pizza <- mu + B * Altitude
Altitude <- phenoorder$Altitude
B <- 0.1
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
plot(density(pvals))
B <- 0
pizza <- mu + B * Altitude
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
simpheno <- mvrnorm(n=100,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
pvals=sapply(1:100,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude)
plot(density(pvals))
Altitude <- phenoorder$Altitude
B <- 0
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=100,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:100,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude)
plot(density(pvals))
hist(pvals)
hist(pvals,breaks-100)
hist(pvals,breaks=100)
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
#EnvVarTest(simpheno[X,],A,Altitude)
plot(density(pvals))
hist(pvals,breaks=100)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector, verbose=F ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
if(verbose){ print(ANOVA) }
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
hist(log(pvals))
length(which(log(pvals)<-3))
length(which(log(pvals))<-3)
length(which(log(pvals))< -3)
length(which(log(pvals)< -3)
)
setwd("~/Documents/Projects/Genome_Size_Analysis")
library(ggplot2)
dataall <- read.csv("Master_Data_noNA.csv")
dataal <- subset(dataall, dataall$X1C_GS!="NA")
data <- subset(dataal, dataal$X1C_GS<3.6)
dmays <- subset(data, data$Species=="mays")
setwd("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SelectionTests/")
library("rrBLUP")
geno <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/Landrace_noSWUS_matrix.csv",header=TRUE,row.names=1)
dt <-t(geno)
A <- A.mat(dt)
pheno <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Landraces_noSWUS_pheno.csv",header=TRUE)
#to make sure order is the same
tmp1 <- as.data.frame(colnames(geno))
names(tmp1)[1] <- "names"
tmp2 <- as.data.frame(pheno$FullID)
tmp <- setdiff(tmp1,tmp2)
phenoorder <- merge(tmp1,pheno, by.x="names", by.y="FullID",sort=FALSE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector, verbose=F ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
if(verbose){ print(ANOVA) }
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
EnvVarTest(phenoorder$X180knobMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$X180knob.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1MB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentCMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentC.,A,phenoorder$Altitude)
length(which(log(pvals)< -2))
library(MASS)
# p = mvn(my + Selection * Altitude, Va * Covariance)
# p will be an output of our phenotypes
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 0.01
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
#install.packages("MASS")
library(MASS)
# p = mvn(my + Selection * Altitude, Va * Covariance)
# p will be an output of our phenotypes
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 0.01
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
hist(pvals,breaks=100)
plot(density(pvals))
#install.packages("MASS")
library(MASS)
# p = mvn(my + Selection * Altitude, Va * Covariance)
# p will be an output of our phenotypes
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 0.0001
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
hist(pvals,breaks=100)
plot(density(pvals))
#install.packages("MASS")
library(MASS)
# p = mvn(my + Selection * Altitude, Va * Covariance)
# p will be an output of our phenotypes
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 0.000001
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
hist(pvals,breaks=100)
plot(density(pvals))
B <- 10
#install.packages("MASS")
library(MASS)
# p = mvn(my + Selection * Altitude, Va * Covariance)
# p will be an output of our phenotypes
mu <- rep(0, 83) #I think since we want 1K sims, we want to make the length of this 1k
Altitude <- phenoorder$Altitude
B <- 10
pizza <- mu + B * Altitude
#covariance matrix is given in A
simpheno <- mvrnorm(n=1000,pizza, A) #n=number of samples we have, for maize 83, for allteo 16 pop
#pieces i am missing: where to stick in altitude?  I think it is at the mu
pvals=sapply(1:1000,function(X) EnvVarTest(simpheno[X,],A,Altitude)[3])
EnvVarTest(simpheno[X,],A,Altitude,verbose=T)
hist(pvals,breaks=100)
plot(density(pvals))
sim <- function ( samples , slope , add.gen.var , gen.covar.mat , altitudes , verbose=F) {
mu <- rep(0, 83)
Altitude <- altitudes
GCM <- gen.covar.mat
B <- slope
env.vector <- mu + B * Altitude
VA = add.gen.var
simpheno <- mvrnorm(n=samples,env.vector, VA*GCM)
pvals=sapply(1:samples,function(X) EnvVarTest(simpheno[X,],gen.covar.mat,Altitude)[3])
hist(pvals,breaks=100)
}
sim(1000,1,1,A,phenoorder$Altitude)
sim(1000,1,1,A,phenoorder$Altitude)
sim(1000,10,1,A,phenoorder$Altitude)
sim(1000,0,1,A,phenoorder$Altitude)
