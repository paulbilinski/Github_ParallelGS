samp <- do.all(specimen, 100, 50, 2)
library(RAFM)
library(driftsel)
samp <- do.all(specimen, 100, 50, 2)
samp <- do.all(specimen, 100, 50, 2)
library(RAFM)
library(driftsel)
samp <- do.all(specimen, 100, 50, 2)
n=100
k=75
theta=0.5
dbinim(x=k,size=n,prob=theta)
dbinom(x=k,size=n,prob=theta)
dunif(theta,min=0,max=1)
dbeta(theta,shape1=10,shape2=10)
curve(dbeta(x=x,10,10),from=0,to=1,n=1001)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001)
curve(dbeta(x=x,1,1),from=0,to=1,n=1001)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001)
dbeta(theta,shape1=10,shape2=10)
uniformProposal = function(theta.current,tuning.parameter) {
theta.prime = runif(n=1,min=theta.current-tuning.parameter/2,max=theta.current+tuning.parameter/2)
if(theta.prime > 1) {
theta.prime = 2-theta.prime
}
if(theta.prime < 0) {
theta.prime = abs(theta.prime)
}
return(theta.prime)
}
uniformProposal = function(theta.current,tuning.parameter=0.1) {
theta.prime = runif(n=1,min=theta.current-tuning.parameter/2,max=theta.current+tuning.parameter/2)
if(theta.prime > 1) {
theta.prime = 2-theta.prime
}
if(theta.prime < 0) {
theta.prime = abs(theta.prime)
}
return(theta.prime)
}
uniformProposal(theta.current = 0.6)
uniformProposal(theta.current = 0.6)
uniformProposal(theta.current = 0.6)
uniformProposal(theta.current = 0.6)
uniformProposal(theta.current = 0.6)
uniformProposal(theta.current = 0.6)
ngen=1e6
sample.freq=100
theta.samples = numeric(ngen/sample.freq)
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
#write the MCMC
ngen=1e6
sample.freq=100
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
theta.samples[i/sample.freq] = theta
}
}
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
theta.samples[i/sample.freq] = theta
}
}
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
theta.samples[i/sample.freq] = theta
}
}
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
mean(theta.samples)
#write the MCMC
ngen=1e6
sample.freq=750
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
accepted.moves/ngen
plot(theta.samples,ylim=c(0,1),type='1')
plot(theta.samples,ylim=c(0,1),type='l')
install.packages('coda')
library(coda)
geweke.diag(theta.samples)
ngen=1e6
sample.freq=100
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
#acceptance rate
accepted.moves/ngen #little high, moving slowly, can just move uniformProposal to be bigger
plot(theta.samples,ylim=c(0,1),type='l')
install.packages('coda')
install.packages("coda")
library(coda)
geweke.diag(theta.samples)
geweke.diag(theta.samples)
ngen=1e6
sample.freq=100
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
geweke.diag(theta.samples)
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
accepted.moves/ngen #little high, moving slowly, can just move uniformProposal to be bigger
plot(theta.samples,ylim=c(0,1),type='l')
geweke.diag(theta.samples)
effectiveSize(theta.samples)
ngen=1e3
sample.freq=1
theta.samples = numeric(ngen/sample.freq)
accepted.moves = 0
theta = rbeta(1,5,5)
l = dbinom(k,n,theta) #likelihood
p = dbeta(theta,5,5) #prior
for(i in 1:ngen) {
theta.prime = uniformProposal(theta) #propose a change to theta
l.prime = dbinom(k,n,theta.prime)
p.prime = dbeta(theta.prime,5,5)
a = (l.prime/l) *(p.prime/p)
if(runif(1,0,1) < a) {
theta= theta.prime
l=l.prime
p=p.prime
accepted.moves = accepted.moves+1
}
if (i %% sample.freq==0) {
cat('*')
theta.samples[i/sample.freq] = theta
}
}
mean(theta.samples)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
#acceptance rate
accepted.moves/ngen #little high, moving slowly, can just move uniformProposal to be bigger
plot(theta.samples,ylim=c(0,1),type='l')
#install.packages('coda')
library(coda)
geweke.diag(theta.samples)
effectiveSize(theta.samples)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
hist(theta.samples,xlim=c(0,1),freq=FALSE)
curve(dbeta(x=x,5,5),from=0,to=1,n=1001,add=TRUE)
plot(theta.samples,ylim=c(0,1),type='l')
5E-5
5E-5 > 6E-5
5E-5 < 6E-5
fit <- aov()
?aov()
library ( mvtnorm )
source('~/.active-rstudio-document', echo=TRUE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( sqrt(eigs$val) )
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
print(ANOVA)
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
phenoteo <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_averages.csv",header=TRUE)
View(phenoteo)
genoteo <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteAll_Bayenv.csv",header=FALSE)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
genoteo <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteAll_Bayenv.csv",header=FALSE)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knob.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knobMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$X180knob.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$TR1MB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$TR1.,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$CentCMB,genoteo,phenoteo$Altitude)
EnvVarTest(phenoteo$CentC.,genoteo,phenoteo$Altitude)
```
phenoparv <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_parv_avg.csv",header=TRUE)
genoparv <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteParv_Bayenv.csv",header=FALSE)
EnvVarTest(phenoparv$X180knobMB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$X180knob.,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$TR1MB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$TR1.,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$CentCMB,genoparv,phenoparv$Altitude)
EnvVarTest(phenoparv$CentC.,genoparv,phenoparv$Altitude)
View(genoteo)
phenomex <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Teosinte_mex_avg.csv",header=TRUE)
genomex <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/TeosinteMex_Bayenv.csv",header=FALSE)
EnvVarTest(phenomex$X180knobMB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$X180knob.,genomex,phenomex$Altitude)
EnvVarTest(phenomex$TR1MB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$TR1.,genomex,phenomex$Altitude)
EnvVarTest(phenomex$CentCMB,genomex,phenomex$Altitude)
EnvVarTest(phenomex$CentC.,genomex,phenomex$Altitude)
setwd("~/Documents/Projects/Genome_Size_Analysis")
library(ggplot2)
dataall <- read.csv("Master_Data_noNA.csv")
dataal <- subset(dataall, dataall$X1C_GS!="NA")
data <- subset(dataal, dataal$X1C_GS<3.6)
dmays <- subset(data, data$Species=="mays")
setwd("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SelectionTests/")
library("rrBLUP")
geno <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/Landrace_noSWUS_matrix.csv",header=TRUE,row.names=1)
dt <-t(geno)
A <- A.mat(dt)
write
#go back to teosinte data, convert to frequencies of allele * 2 so that we get the # of alleles in each individual
pheno <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Landraces_noSWUS_pheno.csv",header=TRUE)
#to make sure order is the same
tmp1 <- as.data.frame(colnames(geno))
names(tmp1)[1] <- "names"
tmp2 <- as.data.frame(pheno$FullID)
tmp <- setdiff(tmp1,tmp2)
phenoorder <- merge(tmp1,pheno, by.x="names", by.y="FullID",sort=FALSE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector, verbose=F ) {
# 'phenos' is a vector containing the phenotype
# (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N;
# rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
eigs <- eigen ( kinship.mat )
# get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( 1/sqrt(eigs$val) ) %*% t ( eigs$vec ) # standardizing distances across each of the eigenvectors so the scale is the same. #change 1 and change 2 dealing with the rotation in and out of transformation
# calculate inverse of the square root matrix
rotated.phenos <- t ( rt.inv ) %*% phenos
# rotate phenotypes from population space into principal component space
test.vector <- test.vector / (sqrt ( 2 * sum ( test.vector^2 ) ) )
# scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% test.vector
# rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ 1+rotated.vector)
# fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2
# get r^2
ANOVA <- anova ( model )
# get p value
if(verbose){ print(ANOVA) }
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] )) # return
}
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N; rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
#recover()
eigs <- eigen ( kinship.mat ) ## get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( 1/sqrt(eigs$val) ) %*% t ( eigs$vec )# calculate inverse of the square root matrix
cent.test.vector <- test.vector - mean ( test.vector )
cent.phenos <- phenos - mean ( phenos )
rotated.phenos <- rt.inv %*% cent.phenos # rotate phenotypes from population space into principal component space
unit.test.vector <- cent.test.vector / (sqrt ( 2 * sum ( cent.test.vector^2 ) ) ) # scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% cent.test.vector # rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ rotated.vector) # fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2 # get r^2
ANOVA <- anova ( model ) # get p value
# expected fraction of variance associated with environmental variable under neutrality
F.env <- ( t ( unit.test.vector ) %*% kinship.mat %*% unit.test.vector ) / sum ( diag ( kinship.mat ) )
sums.sq <- cumsum ( ANOVA[2] )
# fraction of variance associated with environmental variable for trait
Q.env <- sums.sq[1,]/ ( sums.sq[2,] )
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] , ANOVA[3][2,] , F.env , Q.env ) ) # return regression coefficient, r-squared, p value, estimate of Va, F statistic, Q statistic
}
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N; rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
#recover()
eigs <- eigen ( kinship.mat ) ## get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( 1/sqrt(eigs$val) ) %*% t ( eigs$vec )# calculate inverse of the square root matrix
cent.test.vector <- test.vector - mean ( test.vector )
cent.phenos <- phenos - mean ( phenos )
rotated.phenos <- rt.inv %*% cent.phenos # rotate phenotypes from population space into principal component space
unit.test.vector <- cent.test.vector / (sqrt ( 2 * sum ( cent.test.vector^2 ) ) ) # scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% cent.test.vector # rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ rotated.vector) # fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2 # get r^2
ANOVA <- anova ( model ) # get p value
# expected fraction of variance associated with environmental variable under neutrality
F.env <- ( t ( unit.test.vector ) %*% kinship.mat %*% unit.test.vector ) / sum ( diag ( kinship.mat ) )
sums.sq <- cumsum ( ANOVA[2] )
# fraction of variance associated with environmental variable for trait
Q.env <- sums.sq[1,]/ ( sums.sq[2,] )
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] , ANOVA[3][2,] , F.env , Q.env ) ) # return regression coefficient, r-squared, p value, estimate of Va, F statistic, Q statistic
}
EnvVarTest(phenoorder$X180knobMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$X180knob.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TotallTeMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TotallTe.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1MB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$TR1.,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentCMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CentC.,A,phenoorder$Altitude)
p1 <- ggplot(dmays, aes(Region, X1C_GS, color=Region)) + geom_boxplot()+ ylab("1C Genome Size")
p1
p2 <- ggplot(data, aes(Altitude, X180knobMB, color=Species)) + geom_point()+ ylab("MB 180Knob") + theme(legend.title=element_blank()) + geom_smooth(method=lm)
p2
p <- ggplot(data, aes(Altitude, TR1MB, color=Species)) + geom_point()+ ylab("MB TR1") + theme(legend.title=element_blank()) + geom_smooth(method=lm)
p
p <- ggplot(data, aes(Altitude, TotallTeMB, color=Species)) + geom_point()+ ylab("MB TE") + theme(legend.title=element_blank()) + geom_smooth(method=lm)
p
setwd("~/")
data <- read.csv("CRM.abundances2.csv", header=FALSE)
View(data)
?aggregate
test <- aggregate(data,sum)
test <- aggregate(data,FUN=sum)
test <- aggregate(data,FUN="sum")
View(data)
test <- aggregate(data,by=V1,FUN="sum")
test <- aggregate(data,by=data$V1,FUN="sum")
test <- aggregate(data,by=data$V2,FUN="sum")
test <- aggregate(data,by=list(data$V1,data$V2),FUN="sum")
test <- aggregate(data,by=list(data$V1),FUN="sum")
test <- aggregate(V1~V2,data,sum)
View(data)
test <- aggregate(V1~V2,data,mean)
test <- aggregate(V1~V2,data,sum)
test <- aggregate(V2~V1,data,sum)
View(test)
View(test)
setwd("~/Documents/Projects/Genome_Size_Analysis")
library(ggplot2)
dataall <- read.csv("Master_Data_noNA.csv")
dataal <- subset(dataall, dataall$X1C_GS!="NA")
data <- subset(dataal, dataal$X1C_GS<3.6)
dmays <- subset(data, data$Species=="mays")
View(phenoorder)
temp <- merge(test,dmays,by.x=V1,by.y=name)
temp <- merge(test,dmays,by.x="V1",by.y="name")
write.csv(test,"CRMsums.csv")
write.csv(test,"~/CRMsums.csv")
setwd("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SelectionTests/")
library("rrBLUP")
geno <- read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/SNP_data/Landrace_noSWUS_matrix.csv",header=TRUE,row.names=1)
dt <-t(geno)
A <- A.mat(dt)
write
#go back to teosinte data, convert to frequencies of allele * 2 so that we get the # of alleles in each individual
pheno <-read.csv("~/Documents/Projects/Genome_Size_Analysis/Github_ParallelGS/PhenotypeData/Landraces_noSWUS_pheno.csv",header=TRUE)
#to make sure order is the same
tmp1 <- as.data.frame(colnames(geno))
names(tmp1)[1] <- "names"
tmp2 <- as.data.frame(pheno$FullID)
tmp <- setdiff(tmp1,tmp2)
phenoorder <- merge(tmp1,pheno, by.x="names", by.y="FullID",sort=FALSE)
library ( mvtnorm )
EnvVarTest <- function ( phenos , kinship.mat , test.vector ) {
# 'phenos' is a vector containing the phenotype (i.e. number of repeats) for each individual; dimensions are N x 1
# 'kinship.mat' is the kinship matrix; dimensions are N x N; rows and columns need to be in the same order as the phenotypes in the vector
# test.vector is the environmental factor of interest (in this case altitude)
#recover()
eigs <- eigen ( kinship.mat ) ## get eigendecomposition of kinship matrix
rt.inv <- eigs$vec %*% diag ( 1/sqrt(eigs$val) ) %*% t ( eigs$vec )# calculate inverse of the square root matrix
cent.test.vector <- test.vector - mean ( test.vector )
cent.phenos <- phenos - mean ( phenos )
rotated.phenos <- rt.inv %*% cent.phenos # rotate phenotypes from population space into principal component space
unit.test.vector <- cent.test.vector / (sqrt ( 2 * sum ( cent.test.vector^2 ) ) ) # scale to be unit length after rotation
#recover()
rotated.vector <- rt.inv %*% cent.test.vector # rotate environmental variable from population space into principal component space
model <- lm ( rotated.phenos ~ rotated.vector) # fit regression model
r.sq <- cor.test ( rotated.phenos , rotated.vector )$estimate^2 # get r^2
ANOVA <- anova ( model ) # get p value
# expected fraction of variance associated with environmental variable under neutrality
F.env <- ( t ( unit.test.vector ) %*% kinship.mat %*% unit.test.vector ) / sum ( diag ( kinship.mat ) )
sums.sq <- cumsum ( ANOVA[2] )
# fraction of variance associated with environmental variable for trait
Q.env <- sums.sq[1,]/ ( sums.sq[2,] )
return ( c ( model$coef[2] , r.sq , ANOVA[5][[1]][1] , ANOVA[3][2,] , F.env , Q.env ) ) # return regression coefficient, r-squared, p value, estimate of Va, F statistic, Q statistic
}
EnvVarTest(phenoorder$CRMallMB,A,phenoorder$Altitude)
EnvVarTest(phenoorder$CRMall.,A,phenoorder$Altitude)
plot(phenorder$CRMall. ~ phenoorder$Altitude)
plot(phenoorder$CRMall. ~ phenoorder$Altitude)
plot(phenoorder$CRMallMB ~ phenoorder$Altitude)
plot(phenoorder$CRMall. ~ phenoorder$Altitude)
